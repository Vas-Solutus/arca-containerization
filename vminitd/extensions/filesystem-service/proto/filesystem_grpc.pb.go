// Arca Container Filesystem Service Protocol
// gRPC API for container filesystem operations
//
// This service runs on vsock port 51821 in each container's Linux VM
// and provides filesystem operations including:
// - Filesystem sync (flush buffers)
// - Archive operations (tar creation/extraction for buildx)
// - OverlayFS upperdir enumeration (for docker diff)

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.33.0
// source: filesystem.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	FilesystemService_SyncFilesystem_FullMethodName    = "/arca.filesystem.v1.FilesystemService/SyncFilesystem"
	FilesystemService_EnumerateUpperdir_FullMethodName = "/arca.filesystem.v1.FilesystemService/EnumerateUpperdir"
	FilesystemService_ReadArchive_FullMethodName       = "/arca.filesystem.v1.FilesystemService/ReadArchive"
	FilesystemService_WriteArchive_FullMethodName      = "/arca.filesystem.v1.FilesystemService/WriteArchive"
	FilesystemService_CreateBindMount_FullMethodName   = "/arca.filesystem.v1.FilesystemService/CreateBindMount"
)

// FilesystemServiceClient is the client API for FilesystemService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// FilesystemService manages container filesystem operations
// Runs on vsock port 51821 in container's init system namespace
type FilesystemServiceClient interface {
	// Sync filesystem (flush all cached writes to disk)
	// Calls sync() syscall to ensure all filesystem buffers are written
	// Used before reading container filesystem for accurate diff results
	SyncFilesystem(ctx context.Context, in *SyncFilesystemRequest, opts ...grpc.CallOption) (*SyncFilesystemResponse, error)
	// Enumerate upperdir for container diff (OverlayFS-based change detection)
	// Returns all files in /mnt/vdb/upper (added/modified) and whiteouts (deleted)
	// Much faster than full filesystem enumeration
	EnumerateUpperdir(ctx context.Context, in *EnumerateUpperdirRequest, opts ...grpc.CallOption) (*EnumerateUpperdirResponse, error)
	// Read archive - create tar archive of filesystem path
	// Works universally without requiring tar in container
	// Used for GET /containers/{id}/archive endpoint (buildx)
	ReadArchive(ctx context.Context, in *ReadArchiveRequest, opts ...grpc.CallOption) (*ReadArchiveResponse, error)
	// Write archive - extract tar archive to filesystem path
	// Works universally without requiring tar in container
	// Used for PUT /containers/{id}/archive endpoint (buildx)
	WriteArchive(ctx context.Context, in *WriteArchiveRequest, opts ...grpc.CallOption) (*WriteArchiveResponse, error)
	// Create bind mount - bind mount a file or directory to another location
	// Works like "mount --bind /source /target" inside the container
	// Used for file bind mounts (VirtioFS only supports directory shares)
	CreateBindMount(ctx context.Context, in *CreateBindMountRequest, opts ...grpc.CallOption) (*CreateBindMountResponse, error)
}

type filesystemServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFilesystemServiceClient(cc grpc.ClientConnInterface) FilesystemServiceClient {
	return &filesystemServiceClient{cc}
}

func (c *filesystemServiceClient) SyncFilesystem(ctx context.Context, in *SyncFilesystemRequest, opts ...grpc.CallOption) (*SyncFilesystemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncFilesystemResponse)
	err := c.cc.Invoke(ctx, FilesystemService_SyncFilesystem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filesystemServiceClient) EnumerateUpperdir(ctx context.Context, in *EnumerateUpperdirRequest, opts ...grpc.CallOption) (*EnumerateUpperdirResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnumerateUpperdirResponse)
	err := c.cc.Invoke(ctx, FilesystemService_EnumerateUpperdir_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filesystemServiceClient) ReadArchive(ctx context.Context, in *ReadArchiveRequest, opts ...grpc.CallOption) (*ReadArchiveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadArchiveResponse)
	err := c.cc.Invoke(ctx, FilesystemService_ReadArchive_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filesystemServiceClient) WriteArchive(ctx context.Context, in *WriteArchiveRequest, opts ...grpc.CallOption) (*WriteArchiveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WriteArchiveResponse)
	err := c.cc.Invoke(ctx, FilesystemService_WriteArchive_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *filesystemServiceClient) CreateBindMount(ctx context.Context, in *CreateBindMountRequest, opts ...grpc.CallOption) (*CreateBindMountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateBindMountResponse)
	err := c.cc.Invoke(ctx, FilesystemService_CreateBindMount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FilesystemServiceServer is the server API for FilesystemService service.
// All implementations must embed UnimplementedFilesystemServiceServer
// for forward compatibility.
//
// FilesystemService manages container filesystem operations
// Runs on vsock port 51821 in container's init system namespace
type FilesystemServiceServer interface {
	// Sync filesystem (flush all cached writes to disk)
	// Calls sync() syscall to ensure all filesystem buffers are written
	// Used before reading container filesystem for accurate diff results
	SyncFilesystem(context.Context, *SyncFilesystemRequest) (*SyncFilesystemResponse, error)
	// Enumerate upperdir for container diff (OverlayFS-based change detection)
	// Returns all files in /mnt/vdb/upper (added/modified) and whiteouts (deleted)
	// Much faster than full filesystem enumeration
	EnumerateUpperdir(context.Context, *EnumerateUpperdirRequest) (*EnumerateUpperdirResponse, error)
	// Read archive - create tar archive of filesystem path
	// Works universally without requiring tar in container
	// Used for GET /containers/{id}/archive endpoint (buildx)
	ReadArchive(context.Context, *ReadArchiveRequest) (*ReadArchiveResponse, error)
	// Write archive - extract tar archive to filesystem path
	// Works universally without requiring tar in container
	// Used for PUT /containers/{id}/archive endpoint (buildx)
	WriteArchive(context.Context, *WriteArchiveRequest) (*WriteArchiveResponse, error)
	// Create bind mount - bind mount a file or directory to another location
	// Works like "mount --bind /source /target" inside the container
	// Used for file bind mounts (VirtioFS only supports directory shares)
	CreateBindMount(context.Context, *CreateBindMountRequest) (*CreateBindMountResponse, error)
	mustEmbedUnimplementedFilesystemServiceServer()
}

// UnimplementedFilesystemServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFilesystemServiceServer struct{}

func (UnimplementedFilesystemServiceServer) SyncFilesystem(context.Context, *SyncFilesystemRequest) (*SyncFilesystemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncFilesystem not implemented")
}
func (UnimplementedFilesystemServiceServer) EnumerateUpperdir(context.Context, *EnumerateUpperdirRequest) (*EnumerateUpperdirResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnumerateUpperdir not implemented")
}
func (UnimplementedFilesystemServiceServer) ReadArchive(context.Context, *ReadArchiveRequest) (*ReadArchiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadArchive not implemented")
}
func (UnimplementedFilesystemServiceServer) WriteArchive(context.Context, *WriteArchiveRequest) (*WriteArchiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteArchive not implemented")
}
func (UnimplementedFilesystemServiceServer) CreateBindMount(context.Context, *CreateBindMountRequest) (*CreateBindMountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBindMount not implemented")
}
func (UnimplementedFilesystemServiceServer) mustEmbedUnimplementedFilesystemServiceServer() {}
func (UnimplementedFilesystemServiceServer) testEmbeddedByValue()                           {}

// UnsafeFilesystemServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FilesystemServiceServer will
// result in compilation errors.
type UnsafeFilesystemServiceServer interface {
	mustEmbedUnimplementedFilesystemServiceServer()
}

func RegisterFilesystemServiceServer(s grpc.ServiceRegistrar, srv FilesystemServiceServer) {
	// If the following call pancis, it indicates UnimplementedFilesystemServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FilesystemService_ServiceDesc, srv)
}

func _FilesystemService_SyncFilesystem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncFilesystemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilesystemServiceServer).SyncFilesystem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilesystemService_SyncFilesystem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilesystemServiceServer).SyncFilesystem(ctx, req.(*SyncFilesystemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilesystemService_EnumerateUpperdir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnumerateUpperdirRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilesystemServiceServer).EnumerateUpperdir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilesystemService_EnumerateUpperdir_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilesystemServiceServer).EnumerateUpperdir(ctx, req.(*EnumerateUpperdirRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilesystemService_ReadArchive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadArchiveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilesystemServiceServer).ReadArchive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilesystemService_ReadArchive_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilesystemServiceServer).ReadArchive(ctx, req.(*ReadArchiveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilesystemService_WriteArchive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteArchiveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilesystemServiceServer).WriteArchive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilesystemService_WriteArchive_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilesystemServiceServer).WriteArchive(ctx, req.(*WriteArchiveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FilesystemService_CreateBindMount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBindMountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FilesystemServiceServer).CreateBindMount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FilesystemService_CreateBindMount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FilesystemServiceServer).CreateBindMount(ctx, req.(*CreateBindMountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FilesystemService_ServiceDesc is the grpc.ServiceDesc for FilesystemService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FilesystemService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "arca.filesystem.v1.FilesystemService",
	HandlerType: (*FilesystemServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SyncFilesystem",
			Handler:    _FilesystemService_SyncFilesystem_Handler,
		},
		{
			MethodName: "EnumerateUpperdir",
			Handler:    _FilesystemService_EnumerateUpperdir_Handler,
		},
		{
			MethodName: "ReadArchive",
			Handler:    _FilesystemService_ReadArchive_Handler,
		},
		{
			MethodName: "WriteArchive",
			Handler:    _FilesystemService_WriteArchive_Handler,
		},
		{
			MethodName: "CreateBindMount",
			Handler:    _FilesystemService_CreateBindMount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "filesystem.proto",
}
